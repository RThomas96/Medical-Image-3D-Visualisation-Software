#version 400 core

/****************************************/
/**************** Inputs ****************/
/****************************************/
in vec4 vPos;
in vec4 vNorm;
in vec3 texCoord;
in vec4 vPos_PS;

/****************************************/
/*************** Outputs ****************/
/****************************************/
out vec4 color;			// This fragment's color

/****************************************/
/*************** Uniforms ***************/
/****************************************/
uniform usampler3D texData;	// texture generated by the voxel grid generation
uniform vec3 planePositions;	// Positions of all planes, along the direction they show
uniform vec3 planeDirections;	// The directions of the cutting planes, along their axis
uniform vec3 sceneBBPosition;	// The scene's bounding box position
uniform vec3 sceneBBDiagonal;	// The scene's bounding box diagonal
uniform vec2 colorBounds;	// The min/max values of the color scale to display
uniform vec2 textureBounds;	// The min/max values of the texture to display
uniform int currentPlane;	// Plane identifier : 1 (x), 2 (y), 3 (z)
uniform bool showTex;		// Do we show the texture on the plane, or not ?
uniform uint nbChannels;
uniform bool drawOnlyData;	// Should we draw only the data ? not any other plane ?

uniform uint channelView;	// What channels do we visualize ? R+G = 1, R = 2, G = 3
uniform double maxTexPossible;	// maximum tex value possible, variable depending on the data type

uniform bool intersectPlanes = false;	// Should the planes intersect each other ? (hide other planes)

/****************************************/
/*********** Function headers ***********/
/****************************************/
// Takes a grid value and spits out an RGB color by performing a modified HSV2RGB conversion
vec4 R8UIToRGB(in uvec3 ucolor);
vec4 R8UIToRGB_1channel(in uvec3 ucolor);
vec4 R8UIToRGB_2channel(in uvec3 ucolor);
// Determines the plane position along its axis
float planeIdxToPlanePosition(int id);
// Return a color corresponding to a plane's index
vec4 planeIndexToColor();
// Checks if a plane is visible (not hidden by another plane)
bool isPlaneVisible(bool intersect);
// Checks if the plane should be drawn as a simple border, or not.
bool shouldDrawBorder();

/****************************************/
/***************** Main *****************/
/****************************************/
void main(void)
{
	if (isPlaneVisible(true) == false && drawOnlyData) { discard; }
	// Early discard if the plane shouldn't be shown :
	if (isPlaneVisible(intersectPlanes) == false) { discard; }

	// not in border :
	if (shouldDrawBorder() == false) {
		vec4 colorTex = vec4(.0, .0, .0, .0);
		if (texCoord.x > 0. && texCoord.x < 1.) {
			if (texCoord.y > .0 && texCoord.y < 1.) {
				if (texCoord.z > 0. && texCoord.z < 1.) {
					if (isPlaneVisible(true) && showTex == true) {
						uvec3 tex = texture(texData, texCoord).xyz;
						colorTex = R8UIToRGB(tex);
					}
				}
			}
		}
		color = colorTex;
	} else {
		if (showTex == true) {
			color = planeIndexToColor(); // default plane color
		} else {
			discard;
		}
	}

	if (color.a < .1f) { discard; }
}

/****************************************/
/************** Functions ***************/
/****************************************/
vec4 R8UIToRGB(in uvec3 ucolor) {
	// Those are planes in 3D. Alpha stays unchanged when outside texture bounds.
	if (channelView == 1u) {
		if (nbChannels == 1u) { return R8UIToRGB_1channel(ucolor); }
		else { return R8UIToRGB_2channel(ucolor); }
	} else if (channelView == 2u) {
		float alpha = 1.f;
		float val = (float(ucolor.r) - colorBounds.x)/(colorBounds.y-colorBounds.x);
		return vec4(val, val, val, alpha);
	} else if (channelView == 3u) {
		float alpha = 1.f;
		float val = (float(ucolor.g) - colorBounds.x)/(colorBounds.y-colorBounds.x);
		return vec4(val, val, val, alpha);
	}
}
vec4 R8UIToRGB_1channel(in uvec3 ucolor) {
	float color_r = float(ucolor.r);
	float color_g = float(ucolor.r);
	float alpha = 1.;
	// Check if we're in the colorscale. Since drawn on plane, discard fragments by setting alpha < .1 :
	// if (color_r < textureBounds.x || color_r > textureBounds.y) { alpha = .05; }
	// if (color_g < textureBounds.x || color_g > textureBounds.y) { alpha = .05; }
	// clamp values (necessary ?) :
	color_r = clamp(color_r, colorBounds.x, colorBounds.y);
	color_g = clamp(color_g, colorBounds.x, colorBounds.y);
	// Compute the color as Brian's paper describes it :
	float color_k = 2.5;
	float sc = colorBounds.y - colorBounds.x;
	float eosin = (color_r - colorBounds.x)/(sc);
	float dna = (color_g - colorBounds.x)/(sc); // B is on G channel because OpenGL only allows 2 channels upload to be RG, not RB

	float eosin_r_coef = 0.050;
	float eosin_g_coef = 1.000;
	float eosin_b_coef = 0.544;

	float hematoxylin_r_coef = 0.860;
	float hematoxylin_g_coef = 1.000;
	float hematoxylin_b_coef = 0.300;

	float r_coef = eosin_r_coef;
	float g_coef = eosin_g_coef;
	float b_coef = eosin_b_coef;

	vec4 color = vec4(
		exp(-hematoxylin_r_coef * dna * color_k) * exp(-eosin_r_coef * eosin * color_k),
		exp(-hematoxylin_g_coef * dna * color_k) * exp(-eosin_g_coef * eosin * color_k),
		exp(-hematoxylin_b_coef * dna * color_k) * exp(-eosin_b_coef * eosin * color_k),
		alpha
	);

	// if we're not supposed to show the texture AND the plane isn't visible, then discard
	if (showTex == false) { discard; }
	return color;
}
vec4 R8UIToRGB_2channel(in uvec3 ucolor) {
	float color_r = float(ucolor.r);
	float color_g = float(ucolor.g);
	float alpha = 1.;
	// Check if we're in the colorscale. Since drawn on plane, discard fragments by setting alpha < .1 :
	//if (color_r < textureBounds.x || color_r > textureBounds.y) { alpha = .05; }
	//if (color_g < textureBounds.x || color_g > textureBounds.y) { alpha = .05; }
	// clamp values (necessary ?) :
	color_r = clamp(color_r, colorBounds.x, colorBounds.y);
	color_g = clamp(color_g, colorBounds.x, colorBounds.y);
	// Compute the color as Brian's paper describes it :
	float color_k = 2.5;
	float sc = colorBounds.y - colorBounds.x;
	float eosin = (color_r - colorBounds.x)/(sc);
	float dna = (color_g - colorBounds.x)/(sc); // B is on G channel because OpenGL only allows 2 channels upload to be RG, not RB

	float eosin_r_coef = 0.050;
	float eosin_g_coef = 1.000;
	float eosin_b_coef = 0.544;

	float hematoxylin_r_coef = 0.860;
	float hematoxylin_g_coef = 1.000;
	float hematoxylin_b_coef = 0.300;

	float r_coef = eosin_r_coef;
	float g_coef = eosin_g_coef;
	float b_coef = eosin_b_coef;

	vec4 color = vec4(
		exp(-hematoxylin_r_coef * dna * color_k) * exp(-eosin_r_coef * eosin * color_k),
		exp(-hematoxylin_g_coef * dna * color_k) * exp(-eosin_g_coef * eosin * color_k),
		exp(-hematoxylin_b_coef * dna * color_k) * exp(-eosin_b_coef * eosin * color_k),
		alpha
	);

	// if we're not supposed to show the texture AND the plane isn't visible, then discard
	if (showTex == false) { if(isPlaneVisible(intersectPlanes) == false) { color.a = .05; } }
	return color;
}

bool shouldDrawBorder() {
	float min = .01;
	float max = .99;
	if (currentPlane == 1) {
		if (vPos_PS.y > max || vPos_PS.z > max) { return true; }
		if (vPos_PS.y < min || vPos_PS.z < min) { return true; }
	}
	if (currentPlane == 2) {
		if (vPos_PS.x > max || vPos_PS.z > max) { return true; }
		if (vPos_PS.x < min || vPos_PS.z < min) { return true; }
	}
	if (currentPlane == 3) {
		if (vPos_PS.x > max || vPos_PS.y > max) { return true; }
		if (vPos_PS.x < min || vPos_PS.y < min) { return true; }
	}
	return false;
}

float planeIdxToPlanePosition(int id) {
	// displacement to apply :
	vec3 diff = planePositions;
	if (id == 1) { return diff.x; }
	if (id == 2) { return diff.y; }
	if (id == 3) { return diff.z; }
	return 0.f;
}

vec4 planeIndexToColor() {
	if (currentPlane == 1) { return vec4(1., .0, .0, .9); }
	if (currentPlane == 2) { return vec4(.0, 1., .0, .9); }
	if (currentPlane == 3) { return vec4(.0, .0, 1., .9); }
	return vec4(.27, .27, .27, 1.);
}

bool isPlaneVisible(bool intersect) {
	float epsilon = .001f;
	if (((vPos.x - planePositions.x) * planeDirections.x + epsilon) < .0f) { if (intersect) { return false; }}
	if (((vPos.y - planePositions.y) * planeDirections.y + epsilon) < .0f) { if (intersect) { return false; }}
	if (((vPos.z - planePositions.z) * planeDirections.z + epsilon) < .0f) { if (intersect) { return false; }}
	return true;
}
