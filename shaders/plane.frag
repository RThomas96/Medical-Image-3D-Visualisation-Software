#version 400 core

in vec4 vPos;
in vec4 vNorm;
in vec3 texCoord;

out vec4 color;

// Positions of all planes, along the direction they show :
uniform vec3 planePosition;
// The origin of the grid's bounding box
uniform vec3 gridPosition;
uniform uint minTexVal;
uniform uint maxTexVal;

uniform usampler3D texData; // texture generated by the voxel grid generation
uniform sampler1D colorScale; // Color scale generated by the program

vec4 R8UIToRGB(in uvec3 ucolor);

/// Takes a uvec3 of an R8UI-based texture and spits out an RGB color by looking up the color scale
vec4 R8UItoColorScale(in uvec3 ucolor);

void main(void)
{
	vec4 basecolor= vNorm;
	uvec3 tex = texture(texData, texCoord).xyz;
	vec4 colorTex = vec4(.0, .0, .0, .0);
	if (texCoord.x > 0 && texCoord.x < 1) {
		if (texCoord.y > 0 && texCoord.y < 1) {
			if (texCoord.z > 0 && texCoord.z < 1) {
				colorTex = R8UItoColorScale(tex);
			}
		}
	}
	if (colorTex.a < .1f) { discard; }
	vec4 pp4 = planePosition.xyzx; pp4.w = .0;
	vec4 gp4 = gridPosition.xyzx; gp4.w = .0;
	vec4 threshold = gp4 + pp4;
	if ((vPos.x+.01) < threshold.x) { discard; } // Early discards for
	if ((vPos.y+.01) < threshold.y) { discard; } // the parts of the grid
	if ((vPos.z+.01) < threshold.z) { discard; } // behind the planes

	// color = vec4(texCoord.x, texCoord.y, texCoord.z, 1.);
	color = colorTex;
}

vec4 R8UIToRGB(in uvec3 ucolor) {
	if (ucolor.r < minTexVal) { return vec4(.0, .0, .0, .0); }
	if (ucolor.r > maxTexVal) { return vec4(1., 1., 1., 1.); }
	float a = float(minTexVal) / 255.f;
	float b = float(maxTexVal) / 255.f;
	float c = 50.f / 255.f;
	float d = 200.f / 255.f;
	// Get the red component in floating point :
	float r = 1.f - ((b - a) / (d - c)) * ((float(ucolor.r)/255.f)-c)+a;
	// Convert to HSV space (from glsl-hsv2rgb on github) :
	vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	vec3 p = abs(fract(vec3(r,r,r) + K.xyz) * 6.0 - K.www);
	vec3 rgb = mix(K.xxx, clamp(p - K.xxx, .1, .7), r); // change min/max vals of clamp() to change saturation
	return vec4(rgb.r, rgb.g, rgb.b, 1.0);
}

vec4 R8UItoColorScale(in uvec3 ucolor) {
	if (ucolor.r < minTexVal) { return vec4(.0, .0, .0, 1.); }
	if (ucolor.r > maxTexVal) { return vec4(1., 1., 1., 1.); }
	// Only the red component contains the data needed for the color scale :
	float index = float(ucolor.r)/255.;
	vec4 color = texture(colorScale, index);
	color.a = 1.f;
	return color;
}
