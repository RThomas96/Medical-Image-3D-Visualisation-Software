#version 400 core

/****************************************/
/**************** Inputs ****************/
/****************************************/
in vec4 vPos;
in vec4 vNorm;
in vec3 texCoord;
in vec4 vPos_PS;

/****************************************/
/*************** Outputs ****************/
/****************************************/
out vec4 color;			// This fragment's color

/****************************************/
/*************** Uniforms ***************/
/****************************************/
uniform usampler3D texData;	// texture generated by the voxel grid generation
uniform vec3 planePositions;	// Positions of all planes, along the direction they show
uniform vec3 planeDirections;	// The directions of the cutting planes, along their axis
uniform vec3 sceneBBPosition;	// The scene's bounding box position
uniform vec3 sceneBBDiagonal;	// The scene's bounding box diagonal
uniform vec2 colorBounds;	// The min/max values of the color scale to display
uniform vec2 textureBounds;	// The min/max values of the texture to display
uniform int currentPlane;	// Plane identifier : 1 (x), 2 (y), 3 (z)
uniform bool showTex;		// Do we show the texture on the plane, or not ?
uniform bool drawOnlyData;	// Should we draw only the data ? not any other plane ?

uniform vec3 color0;
uniform vec3 color1;

uniform uint channelView;	// What channels do we visualize ? R+G = 1, R = 2, G = 3
uniform uint selectedChannel;	// The selected channel to visualize in greyscale
uniform uint nbChannels;
uniform double maxTexPossible;	// maximum tex value possible, variable depending on the data type

uniform bool intersectPlanes = false;	// Should the planes intersect each other ? (hide other planes)

/****************************************/
/*********** Function headers ***********/
/****************************************/
// [Defined in coloring.glsl] Colors a given fragment.
vec4 voxelIdxToColor(in uvec3 colorParams, in mat3 colorSegment, in vec2 colorBounds, in uvec3 ucolor);
// Determines the plane position along its axis
float planeIdxToPlanePosition(int id);
// Return a color corresponding to a plane's index
vec4 planeIndexToColor();
// Checks if a plane is visible (not hidden by another plane)
bool isPlaneVisible(bool intersect);
// Checks if the plane should be drawn as a simple border, or not.
bool shouldDrawBorder();

/****************************************/
/***************** Main *****************/
/****************************************/
void main(void)
{
	// Early discard if the plane shouldn't be shown :
	if (isPlaneVisible(intersectPlanes) == false) { discard; }

	uvec3 colorParams = uvec3(channelView, selectedChannel, nbChannels);
	mat3 colorSegment = mat3(color0, color1, vec3(.0));

	// not in border :

	vec4 colorTex = vec4(.0, .0, .0, .0);
	if (texCoord.x > 0. && texCoord.x < 1.) {
		if (texCoord.y > .0 && texCoord.y < 1.) {
			if (texCoord.z > 0. && texCoord.z < 1.) {
				if (isPlaneVisible(true) && showTex == true) {
					uvec3 tex = texture(texData, texCoord).xyz;
					colorTex = voxelIdxToColor(colorParams, colorSegment, colorBounds, tex);
				}
			}
		}
	}
	color = colorTex;
	if (shouldDrawBorder() == true && drawOnlyData == true) {
		color = planeIndexToColor();
	}

	if (color.a < .1f) { discard; }
}

/****************************************/
/************** Functions ***************/
/****************************************/
bool shouldDrawBorder() {
	float min = .01;
	float max = .99;
	if (currentPlane == 1) {
		if (vPos_PS.y > max || vPos_PS.z > max) { return true; }
		if (vPos_PS.y < min || vPos_PS.z < min) { return true; }
	}
	if (currentPlane == 2) {
		if (vPos_PS.x > max || vPos_PS.z > max) { return true; }
		if (vPos_PS.x < min || vPos_PS.z < min) { return true; }
	}
	if (currentPlane == 3) {
		if (vPos_PS.x > max || vPos_PS.y > max) { return true; }
		if (vPos_PS.x < min || vPos_PS.y < min) { return true; }
	}
	return false;
}

float planeIdxToPlanePosition(int id) {
	// displacement to apply :
	vec3 diff = planePositions;
	if (id == 1) { return diff.x; }
	if (id == 2) { return diff.y; }
	if (id == 3) { return diff.z; }
	return 0.f;
}

vec4 planeIndexToColor() {
	if (currentPlane == 1) { return vec4(1., .0, .0, .9); }
	if (currentPlane == 2) { return vec4(.0, 1., .0, .9); }
	if (currentPlane == 3) { return vec4(.0, .0, 1., .9); }
	return vec4(.27, .27, .27, 1.);
}

bool isPlaneVisible(bool intersect) {
	float epsilon = .001f;
	if (((vPos.x - planePositions.x) * planeDirections.x + epsilon) < .0f) { if (intersect) { return false; }}
	if (((vPos.y - planePositions.y) * planeDirections.y + epsilon) < .0f) { if (intersect) { return false; }}
	if (((vPos.z - planePositions.z) * planeDirections.z + epsilon) < .0f) { if (intersect) { return false; }}
	return true;
}
