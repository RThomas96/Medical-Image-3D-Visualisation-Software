#version 400 core

/****************************************/
/**************** Inputs ****************/
/****************************************/
in vec4 vPos;
in vec4 vNorm;
in vec3 texCoord;

/****************************************/
/*************** Outputs ****************/
/****************************************/
out vec4 color;			// This fragment's color

/****************************************/
/*************** Uniforms ***************/
/****************************************/
uniform usampler3D texData;	// texture generated by the voxel grid generation
uniform sampler1D colorScale;	// Color scale generated by the program
uniform vec3 planePosition;	// Positions of all planes, along the direction they show
uniform vec3 sceneBBPosition;	// The scene's bounding box position
uniform vec3 sceneBBDiagonal;	// The scene's bounding box diagonal
uniform uint minTexVal;		// The minimum displayed grid value
uniform uint maxTexVal;		// The maximum displayed grid value

/****************************************/
/*********** Function headers ***********/
/****************************************/
// Takes a grid value and spits out an RGB color by looking up at the uniform color scale (see above)
vec4 R8UItoColorScale(in uvec3 ucolor);
// Takes a grid value and spits out an RGB color by performing a modified HSV2RGB conversion
vec4 R8UIToRGB(in uvec3 ucolor);
// Determines the plane position along its axis
float planeIdxToPlanePosition(int id);

/****************************************/
/***************** Main *****************/
/****************************************/
void main(void)
{
	vec4 basecolor= vNorm;
	uvec3 tex = texture(texData, texCoord).xyz;
	vec4 colorTex = vec4(.0, .0, .0, .0);
	if (texCoord.x > 0 && texCoord.x < 1) {
		if (texCoord.y > 0 && texCoord.y < 1) {
			if (texCoord.z > 0 && texCoord.z < 1) {
				colorTex = R8UItoColorScale(tex);
			}
		}
	}
	if (colorTex.a < .1f) { discard; }
	if ((vPos.x+.01) < planeIdxToPlanePosition(1)) { discard; } // Early discards for
	if ((vPos.y+.01) < planeIdxToPlanePosition(2)) { discard; } // the parts of the grid
	if ((vPos.z+.01) < planeIdxToPlanePosition(3)) { discard; } // behind the planes
	// color = vec4(texCoord.x, texCoord.y, texCoord.z, 1.);
	// color = basecolor;
	color = colorTex;
}

/****************************************/
/************** Functions ***************/
/****************************************/
vec4 R8UIToRGB(in uvec3 ucolor) {
	if (ucolor.r < minTexVal) { return vec4(.0, .0, .0, .0); }
	if (ucolor.r > maxTexVal) { return vec4(1., 1., 1., 1.); }
	float a = float(minTexVal) / 255.f;
	float b = float(maxTexVal) / 255.f;
	float c = 50.f / 255.f;
	float d = 200.f / 255.f;
	// Get the red component in floating point :
	float r = 1.f - ((b - a) / (d - c)) * ((float(ucolor.r)/255.f)-c)+a;
	// Convert to HSV space (from glsl-hsv2rgb on github) :
	vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	vec3 p = abs(fract(vec3(r,r,r) + K.xyz) * 6.0 - K.www);
	vec3 rgb = mix(K.xxx, clamp(p - K.xxx, .1, .7), r); // change min/max vals of clamp() to change saturation
	return vec4(rgb.r, rgb.g, rgb.b, 1.0);
}

vec4 R8UItoColorScale(in uvec3 ucolor) {
	if (ucolor.r < minTexVal) { return vec4(.0, .0, .0, 1.); }
	if (ucolor.r > maxTexVal) { return vec4(1., 1., 1., 1.); }
	// Only the red component contains the data needed for the color scale :
	float index = float(ucolor.r)/255.;
	vec4 color = texture(colorScale, index);
	color.a = 1.f;
	return color;
}

float planeIdxToPlanePosition(int id) {
	// displacement to apply :
	vec3 diff = planePosition;
	if (id == 1) { return diff.x; }
	if (id == 2) { return diff.y; }
	if (id == 3) { return diff.z; }
	return 0.f;
}
