#version 400 core

// Signals we're in the main shader, for any shaders inserted into this one.
#define MAIN_SHADER_UNIT

/****************************************/
/**************** Inputs ****************/
/****************************************/
in vec4 vPos;
in vec4 vNorm;
in vec3 texCoord;
in vec4 vPos_PS;

/****************************************/
/*************** Outputs ****************/
/****************************************/
layout(location = 0) out vec4 color;		// This fragment's color
layout(location = 1) out vec4 worldPosition;	// This fragment's world position

/****************************************/
/*************** Uniforms ***************/
/****************************************/
uniform usampler3D texData;	// texture generated by the voxel grid generation
uniform vec3 planePositions;	// Positions of all planes, along the direction they show
uniform vec3 planeDirections;	// The directions of the cutting planes, along their axis
uniform vec3 sceneBBPosition;	// The scene's bounding box position
uniform vec3 sceneBBDiagonal;	// The scene's bounding box diagonal
uniform vec2 colorBounds;	// The min/max values of the color scale to display
uniform vec2 textureBounds;	// The min/max values of the texture to display
uniform vec2 colorBoundsAlternate;	// The min/max values of the color scale to display
uniform vec2 textureBoundsAlternate;	// The min/max values of the texture to display
uniform int currentPlane;	// Plane identifier : 1 (x), 2 (y), 3 (z)
uniform bool showTex;		// Do we show the texture on the plane, or not ?
uniform bool drawOnlyData;	// Should we draw only the data ? not any other plane ?

uniform vec3 color0;
uniform vec3 color1;
uniform vec3 color0Alternate;
uniform vec3 color1Alternate;

uniform uint rgbMode;	// Show only R, only G, or RG

uniform uint r_channelView;	// The coloration function chosen
uniform uint r_selectedChannel;	// The currently selected channel
uniform uint r_nbChannels;	// nb of channels in the image in total (R, RG, RGB ?)
uniform uint g_channelView;	// The coloration function chosen
uniform uint g_selectedChannel;	// The currently selected channel
uniform uint g_nbChannels;	// nb of channels in the image in total (R, RG, RGB ?)

uniform bool intersectPlanes = false;	// Should the planes intersect each other ? (hide other planes)

/****************************************/
/*********** Function headers ***********/
/****************************************/
// Determines the plane position along its axis
float planeIdxToPlanePosition(int id);
// Return a color corresponding to a plane's index
vec4 planeIndexToColor();
// Checks if a plane is visible (not hidden by another plane)
bool isPlaneVisible(bool intersect);
// Checks if the plane should be drawn as a simple border, or not.
bool shouldDrawBorder();
// Check the voxel should be displayed
bool checkAndColorizeVoxel(in uvec3 color, out vec4 return_color);

#pragma include_color_shader;

#line 2066

/****************************************/
/***************** Main *****************/
/****************************************/
void main(void)
{
	worldPosition = vec4(.0,.0,.0,.0);
	// Early discard if the plane shouldn't be shown :
	if (isPlaneVisible(intersectPlanes) == false) { discard; }

	// not in border :
	vec4 colorTex = vec4(.0, .0, .0, .0);
	if (texCoord.x > 0. && texCoord.x < 1.) {
		if (texCoord.y > .0 && texCoord.y < 1.) {
			if (texCoord.z > 0. && texCoord.z < 1.) {
				if (isPlaneVisible(true) && showTex == true) {
					uvec3 tex = texture(texData, texCoord).xyz;
					worldPosition.xyz = sceneBBPosition + texCoord * sceneBBDiagonal;
					worldPosition.w = 1.f;
					if (!checkAndColorizeVoxel(tex, colorTex)) {
						colorTex=vec4(.8, .8, .8, 1.);
					}
				}
			}
		}
	}
	color = colorTex;
	if (shouldDrawBorder() == true && drawOnlyData == true) {
		color = planeIndexToColor();
	}


	if (color.a < .1f) { worldPosition.w = .0f; discard; }
}

/****************************************/
/************** Functions ***************/
/****************************************/
bool shouldDrawBorder() {
	float min = .01;
	float max = .99;
	if (currentPlane == 1) {
		if (vPos_PS.y > max || vPos_PS.z > max) { return true; }
		if (vPos_PS.y < min || vPos_PS.z < min) { return true; }
	}
	if (currentPlane == 2) {
		if (vPos_PS.x > max || vPos_PS.z > max) { return true; }
		if (vPos_PS.x < min || vPos_PS.z < min) { return true; }
	}
	if (currentPlane == 3) {
		if (vPos_PS.x > max || vPos_PS.y > max) { return true; }
		if (vPos_PS.x < min || vPos_PS.y < min) { return true; }
	}
	return false;
}

float planeIdxToPlanePosition(int id) {
	// displacement to apply :
	vec3 diff = planePositions;
	if (id == 1) { return diff.x; }
	if (id == 2) { return diff.y; }
	if (id == 3) { return diff.z; }
	return 0.f;
}

vec4 planeIndexToColor() {
	if (currentPlane == 1) { return vec4(1., .0, .0, .9); }
	if (currentPlane == 2) { return vec4(.0, 1., .0, .9); }
	if (currentPlane == 3) { return vec4(.0, .0, 1., .9); }
	return vec4(.27, .27, .27, 1.);
}

bool isPlaneVisible(bool intersect) {
	float epsilon = .001f;
	if (((vPos.x - planePositions.x) * planeDirections.x + epsilon) < .0f) { if (intersect) { return false; }}
	if (((vPos.y - planePositions.y) * planeDirections.y + epsilon) < .0f) { if (intersect) { return false; }}
	if (((vPos.z - planePositions.z) * planeDirections.z + epsilon) < .0f) { if (intersect) { return false; }}
	return true;
}

bool checkAndColorizeVoxel(in uvec3 voxel, out vec4 return_color) {
	float voxVal;
	vec2 cB, tB;
	bool isRed = false;
	bool canSwitch = false;

	vec4 compColor = voxelIdxToColor(voxel);

	if (rgbMode == 1u) {
		voxVal = float(voxel.r);
		if (voxVal >= textureBounds.x && voxVal < textureBounds.y) {
			compColor = voxelIdxToColor(voxel);
		} else { return false; }
	}
	if (rgbMode == 2u) {
		voxVal = float(voxel.g);
		if (voxVal >= textureBoundsAlternate.x && voxVal < textureBoundsAlternate.y) {
			compColor = voxelIdxToColor(voxel);
		} else { return false; }
	}
	if (rgbMode == 3u) {
		// Just color the thing, see later for boundary conditions :
		compColor = voxelIdxToColor(voxel);
	}

	if (compColor.a < .0f) { return false; }
	return_color = compColor;
	return true;
}
