#version 400 core

#pragma optimize(off)
#pragma debug(on)

// Signals we're in the main shader, for any shaders inserted into this one.
#define MAIN_SHADER_UNIT

in vec4 vPos_WS;
in vec4 vNorm_WS;
in vec3 texCoord;
in vec3 barycentricCoords;
in vec3 largestDelta;

in vec4 vPos_CS;
in vec4 vNorm_CS;
in vec4 lightDir_CS;
in vec4 eyeDir_CS;

out vec4 color;

// Draw modes :
//    - 0u : texture/cube/polygons only
//    - 1u : 0u, but with wireframe on top
//    - 2u : wireframe only, transparent
uniform uint drawMode = 0u;

uniform vec4 lightPos;
uniform usampler3D texData; // texture generated by the voxel grid generation
uniform sampler1D colorScale; // Color scale generated by the program

uniform vec3 sceneBBPosition;
uniform vec3 sceneBBDiagonal;
uniform vec3 voxelGridSize;
uniform vec3 planePositions;
uniform vec3 planeDirections;

uniform vec2 textureBounds;		// Min/max values of the texture to show.
uniform vec2 colorBounds;		// Min/max values to compute the color scale
uniform vec2 textureBoundsAlternate;	// Min/max values of the texture to show.
uniform vec2 colorBoundsAlternate;	// Min/max values to compute the color scale

uniform vec3 color0;	// Start of the color segment
uniform vec3 color1;	// End of the color segment
uniform vec3 color0Alternate;	// Start of the color segment
uniform vec3 color1Alternate;	// End of the color segment

uniform uint channelView;	// What channels do we visualize ? R+G = 1, R = 2, G = 3
uniform uint selectedChannel;	// The currently selected channel
uniform uint nbChannels;	// nb of channels in the image (R, RG, RGB ?)

// Get a plane's coordinate in its axis.
float planeIdxToPlanePosition(int id);
// Checks a fragment is visible, according to the plane positions and directions.
bool isFragmentVisible();

bool checkAndColorizeVoxel(in uvec3 voxel, out vec4 return_color);

INCLUDE_COLOR_FUNCTIONS;

#line 61

void main(void)
{
	// Compute the cutting plane position so that we can threshold the fragments :
	if (isFragmentVisible() == false) { discard; }

	float epsilon = .03;
	float distMin = min(barycentricCoords.x/largestDelta.x, min(barycentricCoords.y/largestDelta.y, barycentricCoords.z/largestDelta.z));

	uvec3 colorParams = uvec3(channelView, selectedChannel, nbChannels);
	mat3 colorSegment = mat3(color0, color1, vec3(.0));

	vec4 basecolor;
	uvec3 ui = texture(texData, texCoord).rgb;

	// computed color :
	vec4 compColor;

	if (!checkAndColorizeVoxel(ui, compColor)) {
		//discard;
	}

	// If we're in the area of a primitive where wireframe is NOT shown :
	if (distMin > epsilon) {
		basecolor = compColor;
		// If we asked for wireframe only, show nothing (alpha=.0)
		if (drawMode == 2) {
			basecolor = vec4(.3, .3, .3, .0);
		}
	}
	// If we're in the area of a primitive where wireframe IS shown :
	else {
		// If asked to do wireframe only, set basecolor to grey only, if wireframe+texture, have a
		// stripe of white surrounding the wireframe (better contrast), if texture only, show it :
		float colorRatio = (drawMode == 2u) ? (.3) : (1. - ((distMin/epsilon < .33 || distMin/epsilon > .66) ? 1. : .0));
		basecolor = (drawMode == 0u) ? compColor : vec4(colorRatio, colorRatio, colorRatio, 1.);
	}

	color = basecolor;

	//if (basecolor.a < 0.1) { discard; } // if transparent, discard the fragment to show others behind it
}


float planeIdxToPlanePosition(int id) {
	// displacement to apply :
	vec3 diff = planePositions - sceneBBPosition;
	if (id == 1) { return diff.x; }
	if (id == 2) { return diff.y; }
	if (id == 3) { return diff.z; }
	return 0.f;
}

bool isFragmentVisible() {
	float epsilon = .01f;
	if (((vPos_WS.x - planePositions.x) * planeDirections.x + epsilon) < .0f) { return false; }
	if (((vPos_WS.y - planePositions.y) * planeDirections.y + epsilon) < .0f) { return false; }
	if (((vPos_WS.z - planePositions.z) * planeDirections.z + epsilon) < .0f) { return false; }
	return true;
}

bool checkAndColorizeVoxel(in uvec3 voxel, out vec4 return_color) {
	// In this function, we'll determine the color the voxel should have. Here is how
	// we determine which channel should be shown, and which should not :
	//	- If there is only one channel to show : (nbChannels == 1)
	//		- Then we colorize the voxel the regular way : with voxel.r
	//	- If not, we'll read the value of the 'primaryChannel' uniform :
	//		- Allows to set the primary[_.*] and secondary[_.*] variables
	//		- Check primary is within its bounds, _AND_ visible in texture :
	//			- if it is, color the voxel according to this and return TRUE
	//			- Otherwise, do the same for secondary. Check bounds, visibility and :
	//				- If available, show it and return TRUE !
	//				- If not, return FALSE !

	// texture coords for visibility :
	uint voxelValue;
	vec2 cB, tB;
	bool isRed = false;
	bool canSwitch = false;
	if (channelView == 1) {
		voxelValue = (selectedChannel == 0) ? voxel.r : voxel.g;
		isRed = (selectedChannel == 0);
		cB = (selectedChannel == 0) ? colorBounds : colorBoundsAlternate;
		tB = (selectedChannel == 0) ? textureBounds : textureBoundsAlternate;
	} else {
		if (nbChannels == 1) {
			voxelValue = voxel.r;
			cB = colorBounds;
			tB = textureBounds;
			isRed = true;
		} else {
			// if we're in greyscale mode, assign values accrding to it :
			voxelValue = voxel.g;
			canSwitch = (nbChannels > 1u);
			isRed = false;
			cB = colorBoundsAlternate;
			tB = textureBoundsAlternate;
		}
	}

	float voxelValue_f = float(voxelValue);

	if (voxelValue_f > tB.x && voxelValue_f < tB.y) {
		return_color = voxelIdxToColor(voxel.xyz);
		return true;
	} else {
		// Is not in the bounds. Check if we can switch :
		if (canSwitch) {
			isRed = !isRed;
			// Set other variables :
			voxelValue = (voxelValue == voxel.r) ? voxel.g : voxel.r;
			voxelValue_f = float(voxelValue);
			cB = colorBounds;
			tB = textureBounds;
			if (voxelValue_f > tB.x && voxelValue_f < tB.y) {
				return_color = voxelIdxToColor(voxel);
				return true;
			}
		}
	}
	return false; // Don't need to compute color, nothing would have been shown ...
}
