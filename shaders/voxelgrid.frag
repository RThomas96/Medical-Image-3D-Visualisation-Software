#version 400 core

#pragma optimize(off)
#pragma debug(on)

// Signals we're in the main shader, for any shaders inserted into this one.
#define MAIN_SHADER_UNIT

in vec4 vPos_WS;
in vec4 vNorm_WS;
in vec3 texCoord;
in vec3 barycentricCoords;
in vec3 largestDelta;

in vec4 vPos_CS;
in vec4 vNorm_CS;
in vec4 lightDir_CS;
in vec4 eyeDir_CS;

out vec4 color;

// Draw modes :
//    - 0u : texture/cube/polygons only
//    - 1u : 0u, but with wireframe on top
//    - 2u : wireframe only, transparent
uniform uint drawMode;

uniform vec4 lightPos;
uniform usampler3D texData; // texture generated by the voxel grid generation
uniform sampler1D colorScale; // Color scale generated by the program

uniform vec3 sceneBBPosition;
uniform vec3 sceneBBDiagonal;
uniform vec3 voxelGridSize;
uniform vec3 planePositions;
uniform vec3 planeDirections;

uniform vec2 colorBounds;		// Min/max values to compute the color scale
uniform vec2 textureBounds;		// Min/max values of the texture to show.
uniform vec2 colorBoundsAlternate;	// Min/max values to compute the color scale
uniform vec2 textureBoundsAlternate;	// Min/max values of the texture to show.

uniform vec3 color0;	// Start of the color segment
uniform vec3 color1;	// End of the color segment
uniform vec3 color0Alternate;	// Start of the color segment
uniform vec3 color1Alternate;	// End of the color segment

uniform uint rgbMode;	// Show only R, only G, or RG

uniform uint r_channelView;	// The coloration function chosen
uniform uint r_selectedChannel;	// The currently selected channel
uniform uint r_nbChannels;	// nb of channels in the image in total (R, RG, RGB ?)
uniform uint g_channelView;	// The coloration function chosen
uniform uint g_selectedChannel;	// The currently selected channel
uniform uint g_nbChannels;	// nb of channels in the image in total (R, RG, RGB ?)

// Get a plane's coordinate in its axis.
float planeIdxToPlanePosition(int id);
// Checks a fragment is visible, according to the plane positions and directions.
bool isFragmentVisible();

bool checkAndColorizeVoxel(in uvec3 voxel, out vec4 return_color);

#pragma include_color_shader;

#line 2066

void main(void)
{
	// Compute the cutting plane position so that we can threshold the fragments :
	if (isFragmentVisible() == false) { discard; }

	float epsilon = .03;
	float distMin = min(barycentricCoords.x/largestDelta.x, min(barycentricCoords.y/largestDelta.y, barycentricCoords.z/largestDelta.z));

	vec4 basecolor;
	uvec3 ui = texture(texData, texCoord).xyz;

	float scR = (float(ui.x) - colorBounds.x) / (colorBounds.y - colorBounds.x);
	float scG = (float(ui.y) - colorBoundsAlternate.x) / (colorBoundsAlternate.y - colorBoundsAlternate.x);
	vec4 rawVals = vec4(scR, scG, .0, 1.);

	// computed color :
	vec4 compColor = vec4(.1,.1, .1, 1.);
	if (checkAndColorizeVoxel(ui, compColor) == false) {
		compColor = vec4(1., .0, .0, .2);
	}

	color = compColor;

	//if (compColor.a < 0.1) { discard; } // if transparent, discard the fragment to show others behind it
}


float planeIdxToPlanePosition(int id) {
	// displacement to apply :
	vec3 diff = planePositions - sceneBBPosition;
	if (id == 1) { return diff.x; }
	if (id == 2) { return diff.y; }
	if (id == 3) { return diff.z; }
	return 0.f;
}

bool isFragmentVisible() {
	float epsilon = .01f;
	if (((vPos_WS.x - planePositions.x) * planeDirections.x + epsilon) < .0f) { return false; }
	if (((vPos_WS.y - planePositions.y) * planeDirections.y + epsilon) < .0f) { return false; }
	if (((vPos_WS.z - planePositions.z) * planeDirections.z + epsilon) < .0f) { return false; }
	return true;
}

bool checkAndColorizeVoxel(in uvec3 voxel, out vec4 return_color) {
	// In this function, we'll determine the color the voxel should have. Here is how
	// we determine which channel should be shown, and which should not :
	//	- If there is only one channel to show : (nbChannels == 1)
	//		- Then we colorize the voxel the regular way : with voxel.r
	//	- If not, we'll read the value of the 'primaryChannel' uniform :
	//		- Allows to set the primary[_.*] and secondary[_.*] variables
	//		- Check primary is within its bounds, _AND_ visible in texture :
	//			- if it is, color the voxel according to this and return TRUE
	//			- Otherwise, do the same for secondary. Check bounds, visibility and :
	//				- If available, show it and return TRUE !
	//				- If not, return FALSE !

	float r = float(voxel.r);
	float g = float(voxel.g);

	bool redVisible = (r >= textureBounds.x) || (r <= textureBounds.y);
	bool greenVisible = (g >= textureBoundsAlternate.x) || (g <= textureBoundsAlternate.y);

	if (rgbMode == 1u) {
		if (redVisible) {
			return_color = voxelIdxToColor(voxel);
			return true;
		} else { return false; }
	} else if (rgbMode == 2u) {
		if (greenVisible) {
			return_color = voxelIdxToColor(voxel);
			return true;
		} else { return false; }
	} else if (rgbMode == 3u) {
		// Just color the thing, see later for boundary conditions :
		return_color = voxelIdxToColor(voxel);
		return true;
	}

	return false;
}
