#version 400 core

// Signals we're in the main shader, for any shaders inserted into this one.
#define MAIN_SHADER_UNIT

in vec4 vPos_WS;
in vec4 vNorm_WS;
in vec3 texCoord;
in vec3 barycentricCoords;
in vec3 largestDelta;

in vec4 vPos_CS;
in vec4 vNorm_CS;
in vec4 lightDir_CS;
in vec4 eyeDir_CS;

out vec4 color;

uniform uint minTexVal;
uniform uint maxTexVal;
uniform vec2 texBounds;		// Min/max values of the texture to show.
uniform vec2 colorBounds;	// Min/max values to compute the color scale
uniform vec2 texBoundsAlternate;		// Min/max values of the texture to show.
uniform vec2 colorBoundsAlternate;	// Min/max values to compute the color scale

// Draw modes :
//    - 0u : texture/cube/polygons only
//    - 1u : 0u, but with wireframe on top
//    - 2u : wireframe only, transparent
uniform uint drawMode;

uniform vec4 lightPos;
uniform usampler3D texData; // texture generated by the voxel grid generation
uniform sampler1D colorScale; // Color scale generated by the program

uniform vec3 sceneBBPosition;
uniform vec3 sceneBBDiagonal;
uniform vec3 voxelGridSize;
uniform vec3 planePositions;
uniform vec3 planeDirections;

uniform vec3 color0;	// Start of the color segment
uniform vec3 color1;	// End of the color segment
uniform vec3 color0Alternate;	// Start of the color segment
uniform vec3 color1Alternate;	// End of the color segment

uniform uint channelView;	// What channels do we visualize ? R+G = 1, R = 2, G = 3
uniform uint selectedChannel;	// The currently selected channel
uniform uint nbChannels;	// nb of channels in the image (R, RG, RGB ?)

// Get a plane's coordinate in its axis.
float planeIdxToPlanePosition(int id);
// Checks a fragment is visible, according to the plane positions and directions.
bool isFragmentVisible();

INCLUDE_COLOR_FUNCTIONS;

void main(void)
{
	// Compute the cutting plane position so that we can threshold the fragments :
	if (isFragmentVisible() == false) { discard; }

	float epsilon = .03;
	float distMin = min(barycentricCoords.x/largestDelta.x, min(barycentricCoords.y/largestDelta.y, barycentricCoords.z/largestDelta.z));

	uvec3 colorParams = uvec3(channelView, selectedChannel, nbChannels);
	mat3 colorSegment = mat3(color0, color1, vec3(.0));

	vec4 basecolor;
	uvec3 ui = texture(texData, texCoord).rgb;

	// computed color :
	vec4 compColor = voxelIdxToColor(ui);

	// If we're in the area of a primitive where wireframe is NOT shown :
	if (distMin > epsilon) {
		basecolor = compColor;
		// If we asked for wireframe only, show nothing (alpha=.0)
		if (drawMode == 2) {
			basecolor = vec4(.3, .3, .3, .0);
		}
	}
	// If we're in the area of a primitive where wireframe IS shown :
	else {
		// If asked to do wireframe only, set basecolor to grey only, if wireframe+texture, have a
		// stripe of white surrounding the wireframe (better contrast), if texture only, show it :
		float colorRatio = (drawMode == 2u) ? (.3) : (1. - ((distMin/epsilon < .33 || distMin/epsilon > .66) ? 1. : .0));
		basecolor = (drawMode == 0u) ? compColor : vec4(colorRatio, colorRatio, colorRatio, 1.);
	}
	float ftexVal = float(ui.r);
	if (selectedChannel == 1u) { ftexVal = float(ui.g); }
	if (ftexVal < texBounds.x || ftexVal > texBounds.y) {
		basecolor = vec4(.8, .8, .8, 1.) ;
	}

	color = basecolor;

	if (basecolor.a < 0.1) { discard; } // if transparent, discard the fragment to show others behind it
}


float planeIdxToPlanePosition(int id) {
	// displacement to apply :
	vec3 diff = planePositions - sceneBBPosition;
	if (id == 1) { return diff.x; }
	if (id == 2) { return diff.y; }
	if (id == 3) { return diff.z; }
	return 0.f;
}

bool isFragmentVisible() {
	float epsilon = .01f;
	if (((vPos_WS.x - planePositions.x) * planeDirections.x + epsilon) < .0f) { return false; }
	if (((vPos_WS.y - planePositions.y) * planeDirections.y + epsilon) < .0f) { return false; }
	if (((vPos_WS.z - planePositions.z) * planeDirections.z + epsilon) < .0f) { return false; }
	return true;
}
