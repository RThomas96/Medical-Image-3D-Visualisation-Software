#version 150 core

// Signals we're in the main shader, for any shaders inserted into this one.
#define MAIN_SHADER_UNIT

#extension GL_ARB_explicit_attrib_location : require

/****************************************/
/**************** Inputs ****************/
/****************************************/
in vec4 vPos;		// The vertex's positions
in vec3 vOriginalCoords;	// The vertex's normal
in vec3 vTexCoords;	// The vertex's texture coordinates
in vec2 planeMultiplier;	// The multiplier used to 'stretch' the plane

/****************************************/
/*************** Outputs ****************/
/****************************************/
layout(location = 0) out vec4 color; // This fragment's color
layout(location = 1) out vec4 finalGridCoordinates;	// The normalized scene coordinates used to fetch textures

/****************************************/
/*************** Uniforms ***************/
/****************************************/
uniform usampler3D texData;	// texture generated by the voxel grid generation
uniform uint planeIndex;	// The identifier of the currently drawn plane.
uniform vec2 colorBounds;
uniform vec2 textureBounds;
uniform vec2 colorBoundsAlternate;
uniform vec2 textureBoundsAlternate;
uniform vec4 sceneBBDiagonal;	// The grid's world-space bounding box diagonal
uniform vec4 sceneBBPosition;	// The grid's world-space bounding box position

uniform vec3 color0;		// Color 0, channel 0
uniform vec3 color1;		// Color 1, channel 0
uniform vec3 color0Alternate;	// Color 0, channel 1
uniform vec3 color1Alternate;	// Color 1, channel 1

uniform uint rgbMode;	// Show only R, only G, or RG

uniform uint r_channelView;	// The coloration function chosen
uniform uint r_selectedChannel;	// The currently selected channel
uniform uint r_nbChannels;	// nb of channels in the image in total (R, RG, RGB ?)
uniform uint g_channelView;	// The coloration function chosen
uniform uint g_selectedChannel;	// The currently selected channel
uniform uint g_nbChannels;	// nb of channels in the image in total (R, RG, RGB ?)

/****************************************/
/*********** Function headers ***********/
/****************************************/
vec4 planeIdxToColor(in uint idx);
bool shouldDiscard();
bool shouldDrawBorder();
bool checkAndColorizeVoxel(in uvec3 voxel, out vec4 color);

#pragma include_color_shader;

#line 2058

/****************************************/
/***************** Main *****************/
/****************************************/
void main() {
	if (shouldDiscard()) { if (!shouldDrawBorder()) { finalGridCoordinates = vec4(.0,.0,.0,.0); discard; } }

	// Default color : plane color
	color = planeIdxToColor(planeIndex);

	// If in the border area, stop there :
	if (shouldDrawBorder() == false) {
		// Get the texture data :
		uvec3 tex = texture(texData, vTexCoords).rgb;

		vec4 final_color;
		if (checkAndColorizeVoxel(tex, final_color)) {
			color = final_color;
		} else {
			// Otherwise, still compute the value but set it with a low alpha
			// to have a bit of context around the texture data.
			color = final_color;
			color.a = .1;
		}
	}

	// Alpha is set to a 2.f to signify we're in the texture (the rest will be set to
	// the value specified udring the call to glClearColor, which is usually in [0, 1]).
	finalGridCoordinates = sceneBBDiagonal * vec4(vTexCoords, 1.f); + sceneBBPosition;
}

/****************************************/
/************** Functions ***************/
/****************************************/
vec4 planeIdxToColor(in uint idx) {
	if (idx == 1u) { return vec4(1., .0, .0, 1.); }
	if (idx == 2u) { return vec4(.0, 1., .0, 1.); }
	if (idx == 3u) { return vec4(.0, .0, 1., 1.); }
	return vec4(.27, .27, .27, 1.);
}

bool shouldDiscard() {
	if (vTexCoords.x > 1. || vTexCoords.y > 1. || vTexCoords.z > 1.) { return true; }
	if (vTexCoords.x < 0. || vTexCoords.y < 0. || vTexCoords.z < 0.) { return true; }
	return false;
}

bool shouldDrawBorder() {
	// Create a border around the image (and try to scale border
	// 'lengths' so they're equal on all sides) :
	float min =-.99;
	float max = .99;
	float minx = min;
	float maxx = max;
	float miny = min;
	float maxy = max;
	if ((vOriginalCoords.x) > maxx || (vOriginalCoords.y) > maxy) { return true; }
	if ((vOriginalCoords.x) < minx || (vOriginalCoords.y) < miny) { return true; }
	return false;
}

bool checkAndColorizeVoxel(in uvec3 voxel, out vec4 return_color) {
	// texture coords for visibility :
	float voxVal;
	vec2 cB, tB;
	bool canSwitch = false;

	vec2 vis = vec2(.0f, .0f);

	voxVal = float(voxel.r);
	if (voxVal >= textureBounds.x && voxVal < textureBounds.y) {
		vis.r = 1.f;
	}
	voxVal = float(voxel.g);
	if (voxVal >= textureBoundsAlternate.x && voxVal < textureBoundsAlternate.y) {
		vis.g = 1.f;
	}

	/*
	WARNING : Since we still want to show the background values of the image here,
	we must still compute the value of return_color but return false.
	*/
	return_color = voxelIdxToColor(voxel, vis);
	if (vis.r < .5f && vis.g < .5f) { return false; }
	if (return_color.a < .0f) { return false; }
	return true;
}
