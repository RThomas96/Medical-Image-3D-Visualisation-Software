#version 150 core

// Signals we're in the main shader, for any shaders inserted into this one.
#define MAIN_SHADER_UNIT

#extension GL_ARB_separate_shader_objects : enable

/****************************************/
/**************** Inputs ****************/
/****************************************/
layout(location = 0) in vec4 vPos;		// The vertex's positions
layout(location = 1) in vec3 vOriginalCoords;	// The vertex's normal
layout(location = 2) in vec3 vTexCoords;	// The vertex's texture coordinates
layout(location = 3) in vec2 planeMultiplier;	// The multiplier used to 'stretch' the plane

/****************************************/
/*************** Outputs ****************/
/****************************************/
layout(location = 0) out vec4 color; // This fragment's color
layout(location = 1) out vec4 finalGridCoordinates;	// The normalized scene coordinates used to fetch textures

/****************************************/
/*************** Uniforms ***************/
/****************************************/
uniform usampler3D texData;	// texture generated by the voxel grid generation
uniform uint planeIndex;	// The identifier of the currently drawn plane.
uniform vec2 colorBounds;
uniform vec2 textureBounds;
uniform vec2 colorBoundsAlternate;
uniform vec2 textureBoundsAlternate;
uniform vec4 sceneBBDiagonal;	// The grid's world-space bounding box diagonal
uniform vec4 sceneBBPosition;	// The grid's world-space bounding box position

uniform vec3 color0;		// Color 0, channel 0
uniform vec3 color1;		// Color 1, channel 0
uniform vec3 color0Alternate;	// Color 0, channel 1
uniform vec3 color1Alternate;	// Color 1, channel 1

uniform uint rgbMode;	// Show only R, only G, or RG

uniform uint r_channelView;	// The coloration function chosen
uniform uint r_selectedChannel;	// The currently selected channel
uniform uint r_nbChannels;	// nb of channels in the image in total (R, RG, RGB ?)
uniform uint g_channelView;	// The coloration function chosen
uniform uint g_selectedChannel;	// The currently selected channel
uniform uint g_nbChannels;	// nb of channels in the image in total (R, RG, RGB ?)

/****************************************/
/*********** Function headers ***********/
/****************************************/
vec4 planeIdxToColor(in uint idx);
bool shouldDiscard();
bool shouldDrawBorder();
bool checkAndColorizeVoxel(in uvec3 voxel, out vec4 color);

#pragma include_color_shader;

#line 2058

/****************************************/
/***************** Main *****************/
/****************************************/
void main() {
	if (shouldDiscard()) { if (!shouldDrawBorder()) { finalGridCoordinates = vec4(.0,.0,.0,.0); discard; } }

	// Default color : plane color
	color = planeIdxToColor(planeIndex);

	// If in the border area, stop there :
	if (shouldDrawBorder() == false) {
		// Get the texture data :
		uvec3 tex = texture(texData, vTexCoords).rgb;

		vec4 final_color;
		if (checkAndColorizeVoxel(tex, final_color)) {
			color = final_color;
		} else {
			// Otherwise, still compute the value but set it with a low alpha
			// to have a bit of context around the texture data.
			color = voxelIdxToColor(tex);
			color.a = .1;
		}
	}

	// Alpha is set to a 2.f to signify we're in the texture (the rest will be set to
	// the value specified udring the call to glClearColor, which is usually in [0, 1]).
	finalGridCoordinates = sceneBBDiagonal * vec4(vTexCoords, 1.f); + sceneBBPosition;
}

/****************************************/
/************** Functions ***************/
/****************************************/
vec4 planeIdxToColor(in uint idx) {
	if (idx == 1u) { return vec4(1., .0, .0, 1.); }
	if (idx == 2u) { return vec4(.0, 1., .0, 1.); }
	if (idx == 3u) { return vec4(.0, .0, 1., 1.); }
	return vec4(.27, .27, .27, 1.);
}

bool shouldDiscard() {
	if (vTexCoords.x > 1. || vTexCoords.y > 1. || vTexCoords.z > 1.) { return true; }
	if (vTexCoords.x < 0. || vTexCoords.y < 0. || vTexCoords.z < 0.) { return true; }
	return false;
}

bool shouldDrawBorder() {
	// Create a border around the image (and try to scale border
	// 'lengths' so they're equal on all sides) :
	float min =-.99;
	float max = .99;
	float minx = min;
	float maxx = max;
	float miny = min;
	float maxy = max;
	if ((vOriginalCoords.x) > maxx || (vOriginalCoords.y) > maxy) { return true; }
	if ((vOriginalCoords.x) < minx || (vOriginalCoords.y) < miny) { return true; }
	return false;
}

bool checkAndColorizeVoxel(in uvec3 voxel, out vec4 return_color) {
	// In this function, we'll determine the color the voxel should have. Here is how
	// we determine which channel should be shown, and which should not :
	//	- If there is only one channel to show : (nbChannels == 1)
	//		- Then we colorize the voxel the regular way : with voxel.r
	//	- If not, we'll read the value of the 'primaryChannel' uniform :
	//		- Allows to set the primary[_.*] and secondary[_.*] variables
	//		- Check primary is within its bounds, _AND_ visible in texture :
	//			- if it is, color the voxel according to this and return TRUE
	//			- Otherwise, do the same for secondary. Check bounds, visibility and :
	//				- If available, show it and return TRUE !
	//				- If not, return FALSE !
	// But for now, as long as there's no uniform blocks, the primary channel will always be green.

	// texture coords for visibility :
	float voxVal;
	vec2 cB, tB;
	bool canSwitch = false;
	vec4 compColor = voxelIdxToColor(voxel);

	if (rgbMode == 1u) {
		voxVal = float(voxel.r);
		if (voxVal >= textureBounds.x && voxVal < textureBounds.y) {
			compColor = voxelIdxToColor(voxel);
		} else { return false; }
	}
	if (rgbMode == 2u) {
		voxVal = float(voxel.g);
		if (voxVal >= textureBoundsAlternate.x && voxVal < textureBoundsAlternate.y) {
			compColor = voxelIdxToColor(voxel);
		} else { return false; }
	}
	if (rgbMode == 3u) {
		// Just color the thing, see later for boundary conditions :
		compColor = voxelIdxToColor(voxel);
	}

	if (compColor.a < .0f) { return false; }
	// unreachable ?
	return_color = compColor;
	return true;
}
