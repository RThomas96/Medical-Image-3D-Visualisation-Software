#version 400 core

// Signals we're in the main shader, for any shaders inserted into this one.
#define MAIN_SHADER_UNIT

#extension GL_ARB_separate_shader_objects : enable

/****************************************/
/**************** Inputs ****************/
/****************************************/
layout(location = 0) in vec4 vPos;		// The vertex's positions
layout(location = 1) in vec3 vOriginalCoords;	// The vertex's normal
layout(location = 2) in vec3 vTexCoords;	// The vertex's texture coordinates
layout(location = 3) in vec2 planeMultiplier;	// The multiplier used to 'stretch' the plane

/****************************************/
/*************** Outputs ****************/
/****************************************/
out vec4 color; // This fragment's color

/****************************************/
/*************** Uniforms ***************/
/****************************************/
uniform usampler3D texData;	// texture generated by the voxel grid generation
uniform uint planeIndex;	// The identifier of the currently drawn plane.
uniform vec2 colorBounds;
uniform vec2 textureBounds;
uniform vec2 colorBoundsAlternate;
uniform vec2 textureBoundsAlternate;

uniform vec3 color0;		// Color 0, channel 0
uniform vec3 color1;		// Color 1, channel 0
uniform vec3 color0Alternate;	// Color 0, channel 1
uniform vec3 color1Alternate;	// Color 1, channel 1

uniform uint channelView;	// What channels do we visualize ? R+G = 1, R = 2, G = 3
uniform uint selectedChannel;	// The selected channel to visualize in greyscale mode
uniform uint nbChannels;	// nb of channels in the image (R, RG, RGB)
uniform double maxTexPossible;	// maximum tex value possible, variable depending on the data type

/****************************************/
/*********** Function headers ***********/
/****************************************/
vec4 planeIdxToColor(in uint idx);
bool shouldDiscard();
bool shouldDrawBorder();
bool checkAndColorizeVoxel(in uvec3 voxel, out vec4 color) ;

INCLUDE_COLOR_FUNCTIONS;

/****************************************/
/***************** Main *****************/
/****************************************/
void main() {
	if (shouldDiscard()) { if (!shouldDrawBorder()) { discard; } }

	uvec3 colorParams = uvec3(channelView, selectedChannel, nbChannels);
	mat3 colorSegment = mat3(color0, color1, vec3(.0));

	// Default color : plane color
	color = planeIdxToColor(planeIndex);

	// If in the border area, stop there :
	if (shouldDrawBorder()) { return; }

	color.xyz = vTexCoords;
	color.a = 1.f;
	// Get the texture data :
	uvec3 tex =  texture(texData, vTexCoords).rgb;

	vec4 final_color;
	if (checkAndColorizeVoxel(tex, final_color)) {
		color = final_color;
	} else {
		color = voxelIdxToColor( tex);
		color.a = .1;
	}
}

/****************************************/
/************** Functions ***************/
/****************************************/
vec4 planeIdxToColor(in uint idx) {
	if (idx == 1) { return vec4(1., .0, .0, 1.); }
	if (idx == 2) { return vec4(.0, 1., .0, 1.); }
	if (idx == 3) { return vec4(.0, .0, 1., 1.); }
	return vec4(.27, .27, .27, 1.);
}

bool shouldDiscard() {
	if (vTexCoords.x > 1. || vTexCoords.y > 1. || vTexCoords.z > 1.) { return true; }
	if (vTexCoords.x < 0. || vTexCoords.y < 0. || vTexCoords.z < 0.) { return true; }
	return false;
}

bool shouldDrawBorder() {
	// Create a border around the image (and try to scale border
	// 'lengths' so they're equal on all sides) :
	float min =-.99;
	float max = .99;
	float minx = min;
	float maxx = max;
	float miny = min;
	float maxy = max;
	if ((vOriginalCoords.x) > maxx || (vOriginalCoords.y) > maxy) { return true; }
	if ((vOriginalCoords.x) < minx || (vOriginalCoords.y) < miny) { return true; }
	return false;
}

bool checkAndColorizeVoxel(in uvec3 voxel, out vec4 return_color) {
	// In this function, we'll determine the color the voxel should have. Here is how
	// we determine which channel should be shown, and which should not :
	//	- If there is only one channel to show : (nbChannels == 1)
	//		- Then we colorize the voxel the regular way : with voxel.r
	//	- If not, we'll read the value of the 'primaryChannel' uniform :
	//		- Allows to set the primary[_.*] and secondary[_.*] variables
	//		- Check primary is within its bounds, _AND_ visible in texture :
	//			- if it is, color the voxel according to this and return TRUE
	//			- Otherwise, do the same for secondary. Check bounds, visibility and :
	//				- If available, show it and return TRUE !
	//				- If not, return FALSE !
	// But for now, as long as there's no uniform blocks, the primary channel will always be green.

	uvec3 colorParams = uvec3(channelView, selectedChannel, nbChannels);
	mat3 colorSegment = mat3(color0, color1, vec3(.0));

	// texture coords for visibility :
	uint voxelValue;
	vec2 cB, tB;
	bool canSwitch = false;
	if (nbChannels == 1) {
		voxelValue = voxel.r;
		cB = colorBounds;
		tB = textureBounds;
	} else {
		// if we're in greyscale mode, assign values accrding to it :
		if (channelView == 1) {
			voxelValue = (selectedChannel == 0) ? voxel.r : voxel.g;
			canSwitch = false; // if not visible from the start, don't show other channel
			cB = (selectedChannel == 0) ? colorBounds : colorBoundsAlternate;
			tB = (selectedChannel == 0) ? textureBounds : textureBoundsAlternate;
		} else {
			voxelValue = voxel.g;
			canSwitch = (nbChannels > 1u);
			cB = colorBoundsAlternate;
			tB = textureBoundsAlternate;
		}
	}

	float voxelValue_f = float(voxelValue);

	if (voxelValue_f > tB.x && voxelValue_f < tB.y) {
		return_color = voxelIdxToColor(voxel.xyz);
		return true;
	} else {
		// Is not in the bounds. Check if we can switch :
		if (canSwitch) {
			// Set other variables :
			voxelValue = (voxelValue == voxel.r) ? voxel.r : voxel.g;
			voxelValue_f = float(voxelValue);
			cB = colorBounds;
			tB = textureBounds;
			if (voxelValue_f > tB.x && voxelValue_f < tB.y) {
				return_color = voxelIdxToColor(voxel);
				return true;
			}
		}
	}
	return false; // Don't need to compute color, nothing would have been shown ...
}
