#version 150 core
#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_explicit_attrib_location : enable

#pragma optimize(off)
#pragma debug(on)

#define INLAYOUT

// Signals we're in the main shader, for any shaders inserted into this one.
#define MAIN_SHADER_UNIT

// The structure which defines every attributes for the color channels.
struct colorChannelAttributes {
	uint isVisible;			// /*align : ui64*/ Is this color channel enabled/visible ?
	uint colorScaleIndex;	// /*align : ui64*/ The color channel to choose
	uvec2 visibleBounds;	// /*align : vec4*/ The bounds of the visible values
	uvec2 colorScaleBounds;	// /*align : vec4*/ The value bounds for the color scale
};

INLAYOUT in vec4 vPos_WS;
INLAYOUT in vec4 vNorm_WS;
INLAYOUT in vec3 texCoord;
INLAYOUT in vec3 barycentricCoords;
INLAYOUT in vec3 largestDelta;

noperspective in vec4 vPos_CS;
noperspective in vec4 vNorm_CS;
noperspective in vec4 lightDir_CS;
noperspective in vec4 eyeDir_CS;

layout(location = 0) out vec4 color;
layout(location = 1) out vec4 worldPosition;

// Draw modes :
//    - 0u : texture/cube/polygons only
//    - 1u : 0u, but with wireframe on top
//    - 2u : wireframe only, transparent
uniform uint drawMode;

uniform vec4 lightPos;
uniform usampler3D texData; // texture generated by the voxel grid generation
uniform sampler1D colorScale; // Color scale generated by the program

uniform vec3 sceneBBPosition;
uniform vec3 sceneBBDiagonal;
uniform vec3 planePositions;
uniform vec3 planeDirections;

// Grid-related information :
uniform vec3 voxelGridOrigin;
uniform vec3 voxelGridSize;
uniform vec3 voxelSize;

uniform uint mainChannelIndex;						// The index of the main channel in the voxel data
uniform sampler1D colorScales[4];					// All the color scales available (all encoded as 1D textures)
layout(std140) uniform ColorBlock {
	colorChannelAttributes attributes[4];	// Color attributes laid out in this way : [ main, R, G, B ]
} colorChannels;

// Get a plane's coordinate in its axis.
float planeIdxToPlanePosition(int id);
// Checks a fragment is visible, according to the plane positions and directions.
bool isFragmentVisible();
// Old function to colorize voxels :
bool checkAndColorizeVoxel(in uvec3 voxel, out vec4 return_color);
// New function to colorize voxels :
vec4 fragmentEvaluationSingleChannel(in uvec3 color);

#pragma include_color_shader;

#line 2069

void main(void)
{
	// Compute the cutting plane position so that we can threshold the fragments :
	if (isFragmentVisible() == false) { color=vec4(.8, .8, .3, 1.); worldPosition.w = .0f; discard; }

	float epsilon = .03;
	float distMin = min(barycentricCoords.x/largestDelta.x, min(barycentricCoords.y/largestDelta.y, barycentricCoords.z/largestDelta.z));

	vec4 basecolor;
	uvec3 ui = texture(texData, texCoord).xyz;
	worldPosition.w = 1.f;

	// computed color :
	vec4 compColor = vec4(.1, .1, .1, 1.);
	vec4 finalColor = fragmentEvaluationSingleChannel(ui);
	if (finalColor.a < .005f) {
		float white_shade = 245.f/255.f;
		compColor = vec4(white_shade, white_shade, white_shade, 1.);
		worldPosition.w = .0f;
	} else {
		compColor = finalColor;
	}

	color = compColor;
	worldPosition.xyz = (voxelGridOrigin + texCoord * voxelGridSize * voxelSize);
}


float planeIdxToPlanePosition(int id) {
	// displacement to apply :
	vec3 diff = planePositions - sceneBBPosition;
	if (id == 1) { return diff.x; }
	if (id == 2) { return diff.y; }
	if (id == 3) { return diff.z; }
	return 0.f;
}

bool isFragmentVisible() {
	float epsilon = .01f;
	if (((vPos_WS.x - planePositions.x) * planeDirections.x + epsilon) < .0f) { return false; }
	if (((vPos_WS.y - planePositions.y) * planeDirections.y + epsilon) < .0f) { return false; }
	if (((vPos_WS.z - planePositions.z) * planeDirections.z + epsilon) < .0f) { return false; }
	return true;
}

bool checkAndColorizeVoxel(in uvec3 voxel, out vec4 return_color) {
	return true;
}
